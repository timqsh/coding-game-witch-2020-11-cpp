(done) Simple bfs with big structure in dict

[debug]
(done) get input from game (cin->cerr) -> python script -> debug with "< input.txt"
(done) profile bfs (gprof)
api -> get timeouts

[optimise bfs]
(done) vector->array
(done) witch.casts -> witch.can_cast + witch.learned
(done) can_cast & learned array<bool> -> bitmask
(done) int -> uint_16 (uint_8 is char...)
(done) map -> unordered_map (maybe hash combine from boost)
optimise search for best path after bfs
more timer checks inside loop (to fix timeouts)
move semantics / less allocations
(done) allocate queue and dict once (to fix timeouts)

[strategy]
(done) multicast in bfs
(done) learn in bfs
(not optimal) don't stop bfs on fastest brew -> return all paths -> choose by price
(done) add brews, score, turns (and maybe learns) to state 
    -> don't stop on first brew
sort by score - turns*1.5 + score(inv)/2. Malus to brew proportional to turns.

smart learn (profit estimate, blue generation)
